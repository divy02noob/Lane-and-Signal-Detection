# Install dependencies if not already installed
!pip install -q ipywidgets opencv-python-headless

import cv2
import numpy as np
import io
import os
from base64 import b64encode
from IPython.display import display, HTML
import ipywidgets as widgets
from google.colab import files

# Define HSV color ranges
def define_color_ranges():
    lower_red1 = np.array([0, 100, 100])
    upper_red1 = np.array([10, 255, 255])
    lower_red2 = np.array([160, 100, 100])
    upper_red2 = np.array([180, 255, 255])
    lower_yellow = np.array([20, 150, 150])
    upper_yellow = np.array([40, 255, 255])
    lower_green = np.array([40, 50, 50])
    upper_green = np.array([90, 255, 255])
    return (lower_red1, upper_red1), (lower_red2, upper_red2), (lower_yellow, upper_yellow), (lower_green, upper_green)

# Traffic light detection
def detect_traffic_light(frame):
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    (lr1, ur1), (lr2, ur2), (ly, uy), (lg, ug) = define_color_ranges()
    red_mask = cv2.inRange(hsv, lr1, ur1) | cv2.inRange(hsv, lr2, ur2)
    yellow_mask = cv2.inRange(hsv, ly, uy)
    green_mask = cv2.inRange(hsv, lg, ug)

    kernel = np.ones((5, 5), np.uint8)
    red_mask = cv2.dilate(cv2.erode(red_mask, kernel), kernel)
    yellow_mask = cv2.dilate(cv2.erode(yellow_mask, kernel), kernel)
    green_mask = cv2.dilate(cv2.erode(green_mask, kernel), kernel)

    contours_red, _ = cv2.findContours(red_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours_yellow, _ = cv2.findContours(yellow_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours_green, _ = cv2.findContours(green_mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    color = "None"
    contours = None

    if contours_red and max([cv2.contourArea(c) for c in contours_red]) > 500:
        return "Red, Stop", contours_red
    elif contours_yellow and max([cv2.contourArea(c) for c in contours_yellow]) > 500:
        return "Yellow, Slow Down", contours_yellow
    elif contours_green and max([cv2.contourArea(c) for c in contours_green]) > 500:
        return "Green, Go", contours_green
    else:
        return color, contours

# Draw bounding box
'''def draw_traffic_light_box(frame, color, contours):
    if contours:
        largest = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largest)
        color_map = {
            "Red, Stop": (0, 0, 255),
            "Yellow, Slow Down": (0, 255, 255),
            "Green, Go": (0, 255, 0),
            "None": (255, 255, 255)
        }
        cv2.rectangle(frame, (x, y), (x+w, y+h), color_map.get(color, (255,255,255)), 4)
    return frame
'''
def detect_traffic_light(frame):
    # Focus on upper part of the image
    height, width, _ = frame.shape
    roi = frame[0:int(height * 0.5), :]  # Top half only
    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)

    (lr1, ur1), (lr2, ur2), (ly, uy), (lg, ug) = define_color_ranges()

    # Color masks
    red_mask = cv2.inRange(hsv, lr1, ur1) | cv2.inRange(hsv, lr2, ur2)
    yellow_mask = cv2.inRange(hsv, ly, uy)
    green_mask = cv2.inRange(hsv, lg, ug)

    # Morphological operations
    kernel = np.ones((5, 5), np.uint8)
    red_mask = cv2.dilate(cv2.erode(red_mask, kernel), kernel)
    yellow_mask = cv2.dilate(cv2.erode(yellow_mask, kernel), kernel)
    green_mask = cv2.dilate(cv2.erode(green_mask, kernel), kernel)

    # Circle detection helper
    def detect_circles(mask):
        circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, dp=1.2, minDist=20,
                                   param1=50, param2=15, minRadius=5, maxRadius=50)
        return circles

    # Try to detect circles in each color
    red_circles = detect_circles(red_mask)
    yellow_circles = detect_circles(yellow_mask)
    green_circles = detect_circles(green_mask)

    if red_circles is not None:
        return "Red, Stop", [np.array([[int(c[0]), int(c[1])]]) for c in red_circles[0]]
    elif yellow_circles is not None:
        return "Yellow, Slow Down", [np.array([[int(c[0]), int(c[1])]]) for c in yellow_circles[0]]
    elif green_circles is not None:
        return "Green, Go", [np.array([[int(c[0]), int(c[1])]]) for c in green_circles[0]]
    else:
        return "None", None

# Lane detection
def detect_lanes(frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(blur, 50, 150)

    height, width = edges.shape
    roi = np.array([[(0, height), (width // 2, height // 2), (width, height)]], dtype=np.int32)
    mask = np.zeros_like(edges)
    cv2.fillPoly(mask, roi, 255)
    masked = cv2.bitwise_and(edges, mask)

    lines = cv2.HoughLinesP(masked, 2, np.pi/180, 100, minLineLength=40, maxLineGap=20)
    line_img = np.zeros_like(frame)

    if lines is not None:
        for l in lines:
            x1, y1, x2, y2 = l[0]
            cv2.line(line_img, (x1, y1), (x2, y2), (0,0,255), 5)
    return cv2.addWeighted(frame, 0.8, line_img, 1, 0)

# Main video processing function
def process_video(input_path, output_path='output_result.mp4'):
    cap = cv2.VideoCapture(input_path)
    width, height = int(cap.get(3)), int(cap.get(4))
    fps = int(cap.get(5))
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        color, contours = detect_traffic_light(frame)
        frame = draw_traffic_light_box(frame, color, contours)
        frame = detect_lanes(frame)
        cv2.putText(frame, f'Traffic Light: {color}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)
        out.write(frame)

    cap.release()
    out.release()

# Display video HTML
def display_video(file_path):
    mp4 = open(file_path,'rb').read()
    data_url = "data:video/mp4;base64," + b64encode(mp4).decode()
    display(HTML(f"""<video width=700 controls><source src="{data_url}" type="video/mp4"></video>"""))

# Upload widget
upload_widget = widgets.FileUpload(accept='.mp4', multiple=False)
process_button = widgets.Button(description="Process Video")
output_area = widgets.Output()

def on_process_clicked(b):
    with output_area:
        output_area.clear_output()
        if upload_widget.value:
            uploaded_filename = list(upload_widget.value.keys())[0]
            uploaded_data = upload_widget.value[uploaded_filename]['content']
            input_path = f'/content/{uploaded_filename}'
            with open(input_path, 'wb') as f:
                f.write(uploaded_data)

            print("Processing...")
            process_video(input_path)
            print("Done! Here's the result:")
            display_video("output_result.mp4")
        else:
            print("Please upload a video first.")

process_button.on_click(on_process_clicked)

# Display frontend UI
display(widgets.VBox([widgets.Label("Upload a .mp4 dashcam video:"), upload_widget, process_button, output_area]))
